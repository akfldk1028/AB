#!/usr/bin/env python3
"""
Mock Claude CLI for testing purposes
"""
import sys
import time

def main():
    # Parse arguments
    args = sys.argv[1:]
    
    # Find the query (last argument)
    query = args[-1] if args else "No query provided"
    
    # Determine response based on context or system prompt
    if "--context" in args:
        context_idx = args.index("--context") + 1
        if context_idx < len(args):
            context_path = args[context_idx]
            
            if "frontend" in context_path:
                response = f"""# React Login Form Component

Here's a simple React login form component with email and password fields:

```jsx
import React, {{ useState }} from 'react';
import './LoginForm.css';

const LoginForm = () => {{
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [isLoading, setIsLoading] = useState(false);

  const handleSubmit = async (e) => {{
    e.preventDefault();
    setIsLoading(true);
    
    try {{
      // Handle login logic here
      console.log('Login attempt:', {{ email, password }});
      // Add your authentication logic
    }} catch (error) {{
      console.error('Login failed:', error);
    }} finally {{
      setIsLoading(false);
    }}
  }};

  return (
    <form className="login-form" onSubmit={{handleSubmit}}>
      <h2>Login</h2>
      
      <div className="form-group">
        <label htmlFor="email">Email:</label>
        <input
          type="email"
          id="email"
          value={{email}}
          onChange={{(e) => setEmail(e.target.value)}}
          required
          placeholder="Enter your email"
        />
      </div>
      
      <div className="form-group">
        <label htmlFor="password">Password:</label>
        <input
          type="password"
          id="password"
          value={{password}}
          onChange={{(e) => setPassword(e.target.value)}}
          required
          placeholder="Enter your password"
        />
      </div>
      
      <button type="submit" disabled={{isLoading}}>
        {{isLoading ? 'Logging in...' : 'Login'}}
      </button>
    </form>
  );
}};

export default LoginForm;
```

## CSS Styles (LoginForm.css)

```css
.login-form {{
  max-width: 400px;
  margin: 0 auto;
  padding: 2rem;
  border: 1px solid #ddd;
  border-radius: 8px;
  box-shadow: 0 2px 10px rgba(0,0,0,0.1);
}}

.form-group {{
  margin-bottom: 1rem;
}}

.form-group label {{
  display: block;
  margin-bottom: 0.5rem;
  font-weight: bold;
}}

.form-group input {{
  width: 100%;
  padding: 0.75rem;
  border: 1px solid #ccc;
  border-radius: 4px;
  font-size: 1rem;
}}

.form-group input:focus {{
  outline: none;
  border-color: #007bff;
  box-shadow: 0 0 0 2px rgba(0,123,255,0.25);
}}

button {{
  width: 100%;
  padding: 0.75rem;
  background-color: #007bff;
  color: white;
  border: none;
  border-radius: 4px;
  font-size: 1rem;
  cursor: pointer;
}}

button:hover:not(:disabled) {{
  background-color: #0056b3;
}}

button:disabled {{
  opacity: 0.6;
  cursor: not-allowed;
}}
```

## Usage

```jsx
import LoginForm from './components/LoginForm';

function App() {{
  return (
    <div className="App">
      <LoginForm />
    </div>
  );
}}
```

This component includes:
- Controlled form inputs for email and password
- Form validation (required fields)
- Loading state during submission
- Accessible labels and proper semantics
- Responsive CSS styling
- Error handling structure

**Generated by Mock Claude CLI for Frontend Development**"""
            
            elif "backend" in context_path:
                response = f"""# REST API for User Authentication

Here's a complete backend implementation for user authentication using FastAPI:

```python
from fastapi import FastAPI, HTTPException, Depends, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from pydantic import BaseModel, EmailStr
from passlib.context import CryptContext
from jose import JWTError, jwt
from datetime import datetime, timedelta
import sqlite3
from typing import Optional

app = FastAPI(title="User Authentication API")

# Security configuration
SECRET_KEY = "your-secret-key-here"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
security = HTTPBearer()

# Pydantic models
class UserCreate(BaseModel):
    email: EmailStr
    password: str
    full_name: str

class UserLogin(BaseModel):
    email: EmailStr
    password: str

class Token(BaseModel):
    access_token: str
    token_type: str

class User(BaseModel):
    id: int
    email: str
    full_name: str
    is_active: bool

# Database functions
def get_db_connection():
    conn = sqlite3.connect('users.db')
    conn.row_factory = sqlite3.Row
    return conn

def init_db():
    conn = get_db_connection()
    conn.execute('''
        CREATE TABLE IF NOT EXISTS users (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            email TEXT UNIQUE NOT NULL,
            hashed_password TEXT NOT NULL,
            full_name TEXT NOT NULL,
            is_active BOOLEAN DEFAULT TRUE
        )
    ''')
    conn.commit()
    conn.close()

# Authentication functions
def verify_password(plain_password, hashed_password):
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password):
    return pwd_context.hash(password)

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=15)
    
    to_encode.update({{"exp": expire}})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

def get_user_by_email(email: str):
    conn = get_db_connection()
    user = conn.execute(
        'SELECT * FROM users WHERE email = ?', (email,)
    ).fetchone()
    conn.close()
    return dict(user) if user else None

def authenticate_user(email: str, password: str):
    user = get_user_by_email(email)
    if not user:
        return False
    if not verify_password(password, user['hashed_password']):
        return False
    return user

async def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security)):
    try:
        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[ALGORITHM])
        email: str = payload.get("sub")
        if email is None:
            raise HTTPException(status_code=401, detail="Invalid token")
    except JWTError:
        raise HTTPException(status_code=401, detail="Invalid token")
    
    user = get_user_by_email(email)
    if user is None:
        raise HTTPException(status_code=401, detail="User not found")
    return user

# API Endpoints
@app.post("/register", response_model=User)
async def register_user(user_data: UserCreate):
    # Check if user already exists
    if get_user_by_email(user_data.email):
        raise HTTPException(
            status_code=400, detail="Email already registered"
        )
    
    # Hash password and create user
    hashed_password = get_password_hash(user_data.password)
    
    conn = get_db_connection()
    cursor = conn.execute(
        'INSERT INTO users (email, hashed_password, full_name) VALUES (?, ?, ?)',
        (user_data.email, hashed_password, user_data.full_name)
    )
    user_id = cursor.lastrowid
    conn.commit()
    conn.close()
    
    return User(
        id=user_id,
        email=user_data.email,
        full_name=user_data.full_name,
        is_active=True
    )

@app.post("/login", response_model=Token)
async def login_user(user_credentials: UserLogin):
    user = authenticate_user(user_credentials.email, user_credentials.password)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect email or password",
            headers={{"WWW-Authenticate": "Bearer"}},
        )
    
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={{"sub": user["email"]}}, expires_delta=access_token_expires
    )
    
    return {{"access_token": access_token, "token_type": "bearer"}}

@app.get("/me", response_model=User)
async def get_current_user_info(current_user: dict = Depends(get_current_user)):
    return User(
        id=current_user["id"],
        email=current_user["email"],
        full_name=current_user["full_name"],
        is_active=current_user["is_active"]
    )

@app.get("/protected")
async def protected_route(current_user: dict = Depends(get_current_user)):
    return {{"message": f"Hello {{current_user['full_name']}}, this is a protected route!"}}

# Initialize database on startup
@app.on_event("startup")
async def startup_event():
    init_db()

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

## Dependencies (requirements.txt)

```
fastapi==0.104.1
uvicorn==0.24.0
python-jose[cryptography]==3.3.0
passlib[bcrypt]==1.7.4
python-multipart==0.0.6
```

## API Usage Examples

### Register a new user
```bash
curl -X POST "http://localhost:8000/register" \\
     -H "Content-Type: application/json" \\
     -d '{{"email": "user@example.com", "password": "securepass", "full_name": "John Doe"}}'
```

### Login
```bash
curl -X POST "http://localhost:8000/login" \\
     -H "Content-Type: application/json" \\
     -d '{{"email": "user@example.com", "password": "securepass"}}'
```

### Access protected route
```bash
curl -X GET "http://localhost:8000/me" \\
     -H "Authorization: Bearer YOUR_JWT_TOKEN"
```

This implementation includes:
- User registration with password hashing
- JWT-based authentication
- Protected routes with token validation
- SQLite database for user storage
- Proper error handling and status codes
- FastAPI automatic documentation

**Generated by Mock Claude CLI for Backend Development**"""
            
            elif "unity" in context_path:
                response = f"""# Unity Character Controller Script

Here's a complete Unity character controller implementation in C#:

```csharp
using UnityEngine;

[RequireComponent(typeof(CharacterController))]
public class ThirdPersonController : MonoBehaviour
{{
    [Header("Movement Settings")]
    public float walkSpeed = 3f;
    public float runSpeed = 6f;
    public float jumpHeight = 2f;
    public float gravity = -9.81f;
    public float groundDistance = 0.4f;
    
    [Header("Input Settings")]
    public string horizontalInput = "Horizontal";
    public string verticalInput = "Vertical";
    public KeyCode runKey = KeyCode.LeftShift;
    public KeyCode jumpKey = KeyCode.Space;
    
    [Header("Ground Check")]
    public Transform groundCheck;
    public LayerMask groundMask = 1;
    
    [Header("Camera")]
    public Transform cameraTransform;
    public float mouseSensitivity = 100f;
    public float cameraUpLimit = 80f;
    public float cameraDownLimit = -80f;
    
    // Private variables
    private CharacterController controller;
    private Vector3 velocity;
    private bool isGrounded;
    private float currentSpeed;
    private float xRotation = 0f;
    
    // Animation (if using Animator)
    private Animator animator;
    
    void Start()
    {{
        controller = GetComponent<CharacterController>();
        animator = GetComponent<Animator>();
        
        // Lock cursor to center of screen
        Cursor.lockState = CursorLockMode.Locked;
        
        // Set up ground check if not assigned
        if (groundCheck == null)
        {{
            GameObject groundCheckObj = new GameObject("GroundCheck");
            groundCheckObj.transform.SetParent(transform);
            groundCheckObj.transform.localPosition = new Vector3(0, -1f, 0);
            groundCheck = groundCheckObj.transform;
        }}
    }}
    
    void Update()
    {{
        HandleGroundCheck();
        HandleMovement();
        HandleRotation();
        HandleJump();
        HandleGravity();
        HandleAnimations();
    }}
    
    void HandleGroundCheck()
    {{
        isGrounded = Physics.CheckSphere(groundCheck.position, groundDistance, groundMask);
        
        if (isGrounded && velocity.y < 0)
        {{
            velocity.y = -2f; // Small downward force to keep grounded
        }}
    }}
    
    void HandleMovement()
    {{
        float horizontal = Input.GetAxis(horizontalInput);
        float vertical = Input.GetAxis(verticalInput);
        
        // Determine movement speed
        bool isRunning = Input.GetKey(runKey);
        currentSpeed = isRunning ? runSpeed : walkSpeed;
        
        // Calculate movement direction relative to camera
        Vector3 forward = cameraTransform.forward;
        Vector3 right = cameraTransform.right;
        
        // Remove y component to prevent flying
        forward.y = 0f;
        right.y = 0f;
        
        forward = forward.normalized;
        right = right.normalized;
        
        // Calculate desired move direction
        Vector3 moveDirection = forward * vertical + right * horizontal;
        moveDirection = moveDirection.normalized;
        
        // Apply movement
        if (moveDirection.magnitude >= 0.1f)
        {{
            // Rotate character to face movement direction
            float targetAngle = Mathf.Atan2(moveDirection.x, moveDirection.z) * Mathf.Rad2Deg;
            transform.rotation = Quaternion.Lerp(transform.rotation, 
                Quaternion.Euler(0f, targetAngle, 0f), 10f * Time.deltaTime);
            
            // Move character
            controller.Move(moveDirection * currentSpeed * Time.deltaTime);
        }}
    }}
    
    void HandleRotation()
    {{
        // Mouse look for camera
        float mouseX = Input.GetAxis("Mouse X") * mouseSensitivity * Time.deltaTime;
        float mouseY = Input.GetAxis("Mouse Y") * mouseSensitivity * Time.deltaTime;
        
        xRotation -= mouseY;
        xRotation = Mathf.Clamp(xRotation, cameraDownLimit, cameraUpLimit);
        
        cameraTransform.localRotation = Quaternion.Euler(xRotation, 0f, 0f);
        transform.Rotate(Vector3.up * mouseX);
    }}
    
    void HandleJump()
    {{
        if (Input.GetKeyDown(jumpKey) && isGrounded)
        {{
            velocity.y = Mathf.Sqrt(jumpHeight * -2f * gravity);
        }}
    }}
    
    void HandleGravity()
    {{
        velocity.y += gravity * Time.deltaTime;
        controller.Move(velocity * Time.deltaTime);
    }}
    
    void HandleAnimations()
    {{
        if (animator != null)
        {{
            // Get input magnitude for animation
            float horizontal = Input.GetAxis(horizontalInput);
            float vertical = Input.GetAxis(verticalInput);
            Vector3 inputVector = new Vector3(horizontal, 0, vertical);
            float inputMagnitude = Mathf.Clamp01(inputVector.magnitude);
            
            // Set animator parameters
            animator.SetFloat("Speed", inputMagnitude * currentSpeed);
            animator.SetBool("IsGrounded", isGrounded);
            animator.SetBool("IsRunning", Input.GetKey(runKey) && inputMagnitude > 0);
            
            if (Input.GetKeyDown(jumpKey) && isGrounded)
            {{
                animator.SetTrigger("Jump");
            }}
        }}
    }}
    
    void OnDrawGizmosSelected()
    {{
        // Draw ground check sphere in editor
        if (groundCheck != null)
        {{
            Gizmos.color = isGrounded ? Color.green : Color.red;
            Gizmos.DrawWireSphere(groundCheck.position, groundDistance);
        }}
    }}
}}
```

## Setup Instructions

1. **Create Character GameObject:**
   - Add CharacterController component
   - Add this ThirdPersonController script
   - Set up your character model as child

2. **Camera Setup:**
   - Create Main Camera as child of character
   - Position camera behind and above character
   - Assign to cameraTransform field

3. **Ground Check:**
   - Create empty GameObject as child
   - Position it at character's feet
   - Assign to groundCheck field

4. **Layer Mask:**
   - Create "Ground" layer
   - Assign ground objects to this layer
   - Set groundMask to "Ground" layer

## Animation Parameters (if using Animator)

- **Speed** (float): Movement speed for blend trees
- **IsGrounded** (bool): Whether character is on ground
- **IsRunning** (bool): Whether character is running
- **Jump** (trigger): Trigger for jump animation

## Features

- Smooth character movement with walk/run speeds
- Mouse look camera control  
- Gravity and jump mechanics
- Ground detection
- Animation support
- Configurable input settings
- Debug visualization

**Generated by Mock Claude CLI for Unity Development**"""
            else:
                response = f"Mock Claude CLI response for query: {query}"
    else:
        response = f"Mock Claude CLI response for query: {query}"
    
    # Simulate some processing time
    time.sleep(1)
    
    # Handle encoding issues
    try:
        print(response)
    except UnicodeEncodeError:
        # Fallback to safe encoding
        print(response.encode('utf-8', errors='replace').decode('utf-8'))

if __name__ == "__main__":
    main()